操作系统实验报告：实验一
沈鸿泽 13061137   何雨 12241014   李超 13061144   纪云钊 13061127
1需求说明
1.1基本要求和提高要求
基本要求：
	能够执行fg、bg、cd、history、exit等内部命令
	能够执行外部程序命令，命令可以带参数
	使用I/O重定向和管道（管道功能可选）
	支持前后台作业，提供作业控制功能，包括打印作业的清单，改变当前运行作业的前台/后台状态，以及控制作业的挂起、中止和继续运行。
	使用make工具建立工程
	使用gdb或者ddd等调试工具来调试程序
	提供清晰、详细的设计文档和解决方案
	锻炼团队成员之间的协作开发能力
提高要求：
尝试在Linux下将flex和bison结合起来使用进行语法和词法分析
通配符的支持与实现，实现星号“*”和问号“？”通配符即可
实现对管道的支持
实现Ctrl+Z
1.2完成情况
	能够执行fg、bg、cd、history、exit等内部命令
	能够执行外部程序命令，命令可以带参数
	能够使用I/O重定向
	支持前后台作业，提供作业控制功能，包括打印作业的清单，改变当前运行作业的前台/后台状态，以及控制作业的挂起、中止和继续运行。
	能够使用make工具建立工程
	能够使用gdb或者ddd等调试工具来调试程序
能够在Linux下将flex和bison结合起来使用进行语法和词法分析
能够实现星号“*”和问号“？”通配符
能够实现对管道的支持
能够实现Ctrl+Z
2设计说明
2.1流程示意图
//图片放在readme里了……

2.2所使用的系统调用的列表
pid_t fork(void)
int execvp(const char *file,char * const argv[])
void exit(int status)
int wait(int *stat_loc)
pid_t waitpid(pid_t pid,int *stat_loc,int options)
int tcsetpgrp(int fildes,pid_t pgid_id)
int setpgid(pid_t pid,pid_t pgid)
int dup2(int fildes,int fildes2)
int pipe(int fildes[2])
2.3提高要求实现说明
通配符的实现：
首先将inputbuff写入cmd的参数列表之前先处理字符串。如果字符串中含有通配符则按照通配符首次出现的位置截取出需匹配的文件名或目录名所在的目录，利用opendir和readdir系统调用按目录查看符合的文件名或目录名，并建立链表。匹配完成后根据建立的链表输入到cmd的参数中。 

词法、语法检查的实现：
删除了原有的yylex()函数，然后用flex重新写了flex.l文件，仿照原来的函数处理方法对flag进行判断并输出是符号还是STRING，bison.y文件里加入了管道的匹配，并在主函数对字符串的循环处理中加入了yy_scan_string(inputBuff);函数以进行字符串分析。

ctrl+c的实现：
通过SIGINT读入ctrlc信号，调用ctrlc函数，在函数内判断是否有前台程序，若存在则在任务链表中找到对应pid进行释放删除，若无前台程序则直接返回。
实现ctrlz:通过SIGTSTP读入ctrlz信号，调用ctrlz函数，在函数内保存当前pid对应进程现场，发送stop信号，使程序暂停挂起。
关于解决fg命令后父进程未等待子进程而是并行执行:通过使用 sigsuspend系列指令屏蔽stop信号，使父进程等待子进程在ctrlz ctrlc之后执行

管道的实现：
管道的实现主要有两点注意，
首先，管道的实现实际上也是一种重定向的处理。对于“前”管道，类似于输入重定向，不同的是，它是把一个指定的描述符（“前”管道的输出端）复制给标准输入。对于“后”管道，类似于输出重定向，不同的是，它把一个指定的描述符（“后”管道的输入端）复制给标准输出。
其次，管道命令可以看成一个简单命令和另一个管道命令组合而成，以ls|wc|wc|wc为例，相当于ls和后面的wc|wc|wc之间通过管道连接，建立管道，然后接下来就是递归的处理wc|wc|wc了。
对源码中后台命令的bug进行了修正：
源码在执行后台命令的时候，子父进程由于执行顺序的不确定性，容易产生死锁，处理的办法是只保留了父进程向子进程通过kill发送消息，子进程signal得到消息并处理，删除了子进程向父进程发送消息的语句。

3收获与感想
3.1给予你帮助的人
感谢樊皓楠同学告诉我yy_scan_string()这个函数。
3.2从实验中学到的东西
实验确实对我们在操作系统的学习上有所帮助：
1、	首先我们在Linux相关软件工具的使用上熟悉了gcc，gdb以及make。
2、	熟悉并基本掌握了用flex和bison联合写出c语言的语法词法分析器。
3、	提高了我们分析代码，发现代码问题以及解决代码bug的能力。
4、	学习了shell上相关指令的实现以及shell的运行流程，能够明白程序是在哪一步分别调用了哪些函数来进行处理。
5、	明白了前台程序与后台程序的区别，ctrl+z，ctrl+c的相应功能以及与bg，fg的关系。
6、	明白了管道的实现方法并实现了管道的支持。
7、	学会了我们在团队合作的时候应该怎样分配任务，怎样进行工作上的合作与讨论，怎样对每个人的工作部分进行整个与调试。提高了团队成员之间的协作开发能力。
